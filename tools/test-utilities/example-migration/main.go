package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	
	"github.com/gotrs-io/gotrs-ce/internal/database"
	_ "github.com/gotrs-io/gotrs-ce/internal/database/drivers/mysql"
	_ "github.com/gotrs-io/gotrs-ce/internal/database/drivers/postgres"
	_ "github.com/gotrs-io/gotrs-ce/internal/database/drivers/sqlite"
	"github.com/gotrs-io/gotrs-ce/internal/database/schema"
)

func main() {
	var (
		schemaDir  = flag.String("schemas", "schemas", "Directory containing YAML schema files")
		targetDB   = flag.String("target", "postgres", "Target database type (postgres, mysql, sqlite)")
		outputFile = flag.String("output", "", "Output SQL file (default: stdout)")
	)
	flag.Parse()
	
	fmt.Fprintf(os.Stderr, "GOTRS Migration Generator\n")
	fmt.Fprintf(os.Stderr, "========================\n\n")
	
	// Load schemas
	loader := schema.NewSchemaLoader(*schemaDir)
	if err := loader.LoadAll(); err != nil {
		log.Fatal("Failed to load schemas:", err)
	}
	
	schemas := loader.GetAllSchemas()
	fmt.Fprintf(os.Stderr, "Loaded %d schemas from %s\n", len(schemas), *schemaDir)
	
	// Get target driver
	driver, err := database.GetDriver(*targetDB)
	if err != nil {
		log.Fatal("Failed to get driver:", err)
	}
	
	// For demonstration, we'll just connect to an in-memory SQLite
	// In production, you'd use real connection strings
	if *targetDB == "sqlite" {
		ctx := context.Background()
		if err := driver.Connect(ctx, ":memory:"); err != nil {
			log.Fatal("Failed to connect:", err)
		}
		defer driver.Close()
	}
	
	// Generate SQL for all schemas
	fmt.Fprintf(os.Stderr, "\nGenerating SQL for %s...\n\n", *targetDB)
	
	var output *os.File
	if *outputFile != "" {
		output, err = os.Create(*outputFile)
		if err != nil {
			log.Fatal("Failed to create output file:", err)
		}
		defer output.Close()
	} else {
		output = os.Stdout
	}
	
	// Write header
	fmt.Fprintf(output, "-- Generated by GOTRS Migration Generator\n")
	fmt.Fprintf(output, "-- Target: %s\n", *targetDB)
	fmt.Fprintf(output, "-- Schemas: %d\n\n", len(schemas))
	
	// Generate CREATE TABLE statements
	for tableName, tableSchema := range schemas {
		fmt.Fprintf(os.Stderr, "Processing table: %s\n", tableName)
		
		query, err := driver.CreateTable(tableSchema)
		if err != nil {
			log.Printf("Failed to generate SQL for %s: %v", tableName, err)
			continue
		}
		
		fmt.Fprintf(output, "-- Table: %s\n", tableName)
		fmt.Fprintf(output, "%s;\n\n", query.SQL)
	}
	
	// Show type mappings
	fmt.Fprintf(os.Stderr, "\nType mappings for %s:\n", *targetDB)
	commonTypes := []string{"serial", "bigserial", "varchar(200)", "text", "timestamp", "boolean", "json"}
	for _, t := range commonTypes {
		mapped := driver.MapType(t)
		fmt.Fprintf(os.Stderr, "  %-15s -> %s\n", t, mapped)
	}
	
	// Show feature support
	fmt.Fprintf(os.Stderr, "\nFeature support for %s:\n", *targetDB)
	fmt.Fprintf(os.Stderr, "  RETURNING clause:  %v\n", driver.SupportsReturning())
	fmt.Fprintf(os.Stderr, "  LastInsertId:      %v\n", driver.SupportsLastInsertId())
	fmt.Fprintf(os.Stderr, "  Arrays:            %v\n", driver.SupportsArrays())
	
	if *outputFile != "" {
		fmt.Fprintf(os.Stderr, "\nâœ… SQL written to %s\n", *outputFile)
	}
}