#!/usr/bin/env node

/**
 * Generate TypeScript types from OpenAPI specification
 * This script reads the OpenAPI spec and generates TypeScript interfaces
 * for frontend type safety and contract validation.
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

const OPENAPI_FILE = path.join(__dirname, '../api/openapi.yaml');
const OUTPUT_FILE = path.join(__dirname, '../web/src/types/api.ts');

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function toPascalCase(str) {
  return str.split(/[-_]/).map(capitalize).join('');
}

function typeFromSchema(schema, definitions = {}) {
  if (schema.$ref) {
    const refName = schema.$ref.split('/').pop();
    return refName;
  }

  switch (schema.type) {
    case 'string':
      if (schema.enum) {
        return schema.enum.map(v => `'${v}'`).join(' | ');
      }
      if (schema.format === 'date-time') {
        return 'string'; // Could use Date if preferred
      }
      return 'string';
    
    case 'integer':
    case 'number':
      return 'number';
    
    case 'boolean':
      return 'boolean';
    
    case 'array':
      return `${typeFromSchema(schema.items, definitions)}[]`;
    
    case 'object':
      if (schema.properties) {
        const props = Object.entries(schema.properties).map(([key, prop]) => {
          const optional = schema.required && !schema.required.includes(key) ? '?' : '';
          const nullable = prop.nullable ? ' | null' : '';
          return `  ${key}${optional}: ${typeFromSchema(prop, definitions)}${nullable};`;
        }).join('\n');
        return `{\n${props}\n}`;
      }
      return 'Record<string, any>';
    
    default:
      return 'any';
  }
}

function generateInterface(name, schema) {
  const props = Object.entries(schema.properties || {}).map(([key, prop]) => {
    const optional = schema.required && !schema.required.includes(key) ? '?' : '';
    const nullable = prop.nullable ? ' | null' : '';
    const description = prop.description ? `  /** ${prop.description} */\n` : '';
    return `${description}  ${key}${optional}: ${typeFromSchema(prop)}${nullable};`;
  }).join('\n');

  const description = schema.description ? `/**\n * ${schema.description}\n */\n` : '';
  return `${description}export interface ${name} {\n${props}\n}`;
}

function generateTypes() {
  try {
    // Read OpenAPI spec
    const specContent = fs.readFileSync(OPENAPI_FILE, 'utf8');
    const spec = yaml.load(specContent);

    if (!spec.components || !spec.components.schemas) {
      throw new Error('No schemas found in OpenAPI specification');
    }

    // Generate TypeScript content
    let content = `// Auto-generated types from OpenAPI specification
// Do not edit this file manually - it will be overwritten
// Generated at: ${new Date().toISOString()}

`;

    // Generate interfaces for all schemas
    Object.entries(spec.components.schemas).forEach(([name, schema]) => {
      content += generateInterface(name, schema) + '\n\n';
    });

    // Generate API endpoint types
    content += `// API Endpoint Types\n\n`;

    // Generate request/response types for each endpoint
    Object.entries(spec.paths || {}).forEach(([path, methods]) => {
      Object.entries(methods).forEach(([method, operation]) => {
        if (!operation.operationId) return;

        const operationName = toPascalCase(operation.operationId);

        // Generate request type if requestBody exists
        if (operation.requestBody && operation.requestBody.content) {
          const jsonContent = operation.requestBody.content['application/json'];
          if (jsonContent && jsonContent.schema) {
            const requestType = typeFromSchema(jsonContent.schema);
            content += `export type ${operationName}Request = ${requestType};\n`;
          }
        }

        // Generate response types
        Object.entries(operation.responses || {}).forEach(([status, response]) => {
          if (response.content && response.content['application/json']) {
            const schema = response.content['application/json'].schema;
            const responseType = typeFromSchema(schema);
            const statusName = status === '200' || status === '201' ? 'Success' : `Error${status}`;
            content += `export type ${operationName}${statusName}Response = ${responseType};\n`;
          }
        });

        content += '\n';
      });
    });

    // Generate API client interface
    content += `// API Client Types\n\n`;
    content += `export interface ApiClient {\n`;

    Object.entries(spec.paths || {}).forEach(([path, methods]) => {
      Object.entries(methods).forEach(([method, operation]) => {
        if (!operation.operationId) return;

        const operationName = operation.operationId;
        const hasRequest = operation.requestBody && operation.requestBody.content;
        const parameters = (operation.parameters || []).filter(p => p.required).length;
        
        let params = [];
        if (parameters > 0) {
          params.push('params: Record<string, any>');
        }
        if (hasRequest) {
          params.push(`data: ${toPascalCase(operation.operationId)}Request`);
        }

        const returnType = `Promise<${toPascalCase(operation.operationId)}SuccessResponse>`;
        content += `  ${operationName}(${params.join(', ')}): ${returnType};\n`;
      });
    });

    content += `}\n\n`;

    // Add utility types
    content += `// Utility Types\n\n`;
    content += `export type ApiResponse<T = any> = {\n`;
    content += `  success: boolean;\n`;
    content += `  data?: T;\n`;
    content += `  error?: string;\n`;
    content += `};\n\n`;

    content += `export type ApiError = {\n`;
    content += `  message: string;\n`;
    content += `  status: number;\n`;
    content += `  code?: string;\n`;
    content += `};\n`;

    // Ensure output directory exists
    const outputDir = path.dirname(OUTPUT_FILE);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Write the generated types
    fs.writeFileSync(OUTPUT_FILE, content);
    
    console.log(`‚úÖ Generated TypeScript types: ${OUTPUT_FILE}`);
    console.log(`üìä Generated ${Object.keys(spec.components.schemas).length} interfaces`);

  } catch (error) {
    console.error('‚ùå Error generating types:', error.message);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  generateTypes();
}

module.exports = { generateTypes };