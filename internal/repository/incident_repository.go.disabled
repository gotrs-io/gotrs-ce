package repository

import (
	"fmt"
	"time"

	"github.com/gotrs-io/gotrs-ce/internal/models"
	"gorm.io/gorm"
)

// IIncidentRepository defines the interface for incident repository
type IIncidentRepository interface {
	Create(incident *models.Incident) error
	GetByID(id uint) (*models.Incident, error)
	GetByNumber(number string) (*models.Incident, error)
	Update(incident *models.Incident) error
	Delete(id uint) error
	List(req *models.IncidentListRequest) (*models.IncidentListResponse, error)
	
	// Status and assignment operations
	UpdateStatus(id uint, status models.IncidentStatus) error
	AssignTo(id uint, userID uint, groupID *uint) error
	Escalate(id uint, level int) error
	
	// Relationship operations
	LinkToTicket(incidentID uint, ticketID uint) error
	LinkToProblem(incidentID uint, problemID uint) error
	LinkToCI(incidentID uint, ciID uint) error
	GetRelatedIncidents(id uint) ([]*models.Incident, error)
	
	// Comment operations
	AddComment(comment *models.IncidentComment) error
	GetComments(incidentID uint) ([]*models.IncidentComment, error)
	
	// Attachment operations
	AddAttachment(attachment *models.IncidentAttachment) error
	GetAttachments(incidentID uint) ([]*models.IncidentAttachment, error)
	DeleteAttachment(id uint) error
	
	// History operations
	AddHistory(history *models.IncidentHistory) error
	GetHistory(incidentID uint) ([]*models.IncidentHistory, error)
	
	// Metrics and analytics
	GetMetrics(from, to time.Time) (*IncidentMetrics, error)
	GetSLACompliance(from, to time.Time) (*SLAMetrics, error)
	GetTrendAnalysis(period string) (*TrendAnalysis, error)
}

// IncidentRepository implements the incident repository interface
type IncidentRepository struct {
	db *gorm.DB
}

// NewIncidentRepository creates a new incident repository
func NewIncidentRepository(db *gorm.DB) IIncidentRepository {
	return &IncidentRepository{db: db}
}

// Create creates a new incident
func (r *IncidentRepository) Create(incident *models.Incident) error {
	if incident == nil {
		return fmt.Errorf("incident cannot be nil")
	}
	
	// Generate incident number if not provided
	if incident.IncidentNumber == "" {
		incident.IncidentNumber = r.generateIncidentNumber()
	}
	
	// Calculate priority based on impact and urgency
	incident.CalculatePriority()
	
	// Set reported time if not set
	if incident.ReportedAt.IsZero() {
		incident.ReportedAt = time.Now()
	}
	
	// Set initial status
	if incident.Status == "" {
		incident.Status = models.IncidentStatusNew
	}
	
	// Start transaction
	tx := r.db.Begin()
	
	// Create the incident
	if err := tx.Create(incident).Error; err != nil {
		tx.Rollback()
		return fmt.Errorf("failed to create incident: %w", err)
	}
	
	// Add initial history entry
	history := &models.IncidentHistory{
		IncidentID:  incident.ID,
		FieldName:   "status",
		OldValue:    "",
		NewValue:    string(incident.Status),
		ChangedByID: incident.CreatedByID,
		ChangeType:  "create",
	}
	
	if err := tx.Create(history).Error; err != nil {
		tx.Rollback()
		return fmt.Errorf("failed to create incident history: %w", err)
	}
	
	return tx.Commit().Error
}

// GetByID retrieves an incident by ID
func (r *IncidentRepository) GetByID(id uint) (*models.Incident, error) {
	var incident models.Incident
	err := r.db.Preload("AssignedTo").
		Preload("AssignmentGroup").
		Preload("ReportedBy").
		Preload("AffectedUser").
		Preload("RelatedTicket").
		Preload("Problem").
		Preload("ConfigurationItem").
		Preload("Service").
		First(&incident, id).Error
	
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("incident not found")
		}
		return nil, fmt.Errorf("failed to get incident: %w", err)
	}
	
	return &incident, nil
}

// GetByNumber retrieves an incident by incident number
func (r *IncidentRepository) GetByNumber(number string) (*models.Incident, error) {
	var incident models.Incident
	err := r.db.Where("incident_number = ?", number).
		Preload("AssignedTo").
		Preload("AssignmentGroup").
		Preload("ReportedBy").
		First(&incident).Error
	
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, fmt.Errorf("incident not found")
		}
		return nil, fmt.Errorf("failed to get incident: %w", err)
	}
	
	return &incident, nil
}

// Update updates an existing incident
func (r *IncidentRepository) Update(incident *models.Incident) error {
	if incident == nil || incident.ID == 0 {
		return fmt.Errorf("invalid incident")
	}
	
	// Get original incident for history tracking
	var original models.Incident
	if err := r.db.First(&original, incident.ID).Error; err != nil {
		return fmt.Errorf("failed to get original incident: %w", err)
	}
	
	// Recalculate priority if impact or urgency changed
	if incident.Impact != original.Impact || incident.Urgency != original.Urgency {
		incident.CalculatePriority()
	}
	
	// Update metrics
	if incident.Status != original.Status {
		r.updateMetrics(incident, &original)
	}
	
	// Start transaction
	tx := r.db.Begin()
	
	// Update the incident
	if err := tx.Save(incident).Error; err != nil {
		tx.Rollback()
		return fmt.Errorf("failed to update incident: %w", err)
	}
	
	// Track status changes in history
	if incident.Status != original.Status {
		history := &models.IncidentHistory{
			IncidentID:  incident.ID,
			FieldName:   "status",
			OldValue:    string(original.Status),
			NewValue:    string(incident.Status),
			ChangedByID: incident.LastModifiedByID.(*uint),
			ChangeType:  "update",
		}
		
		if err := tx.Create(history).Error; err != nil {
			tx.Rollback()
			return fmt.Errorf("failed to create history: %w", err)
		}
	}
	
	return tx.Commit().Error
}

// Delete deletes an incident
func (r *IncidentRepository) Delete(id uint) error {
	return r.db.Delete(&models.Incident{}, id).Error
}

// List retrieves a paginated list of incidents
func (r *IncidentRepository) List(req *models.IncidentListRequest) (*models.IncidentListResponse, error) {
	if req == nil {
		req = &models.IncidentListRequest{
			Page:    1,
			PerPage: 20,
		}
	}
	
	// Set defaults
	if req.Page < 1 {
		req.Page = 1
	}
	if req.PerPage < 1 {
		req.PerPage = 20
	}
	if req.PerPage > 100 {
		req.PerPage = 100
	}
	
	// Build query
	query := r.db.Model(&models.Incident{}).
		Preload("AssignedTo").
		Preload("AssignmentGroup").
		Preload("ReportedBy")
	
	// Apply filters
	if req.Status != "" {
		query = query.Where("status = ?", req.Status)
	}
	if req.Severity != "" {
		query = query.Where("severity = ?", req.Severity)
	}
	if req.Category != "" {
		query = query.Where("category = ?", req.Category)
	}
	if req.AssignedToID > 0 {
		query = query.Where("assigned_to_id = ?", req.AssignedToID)
	}
	if req.ReportedByID > 0 {
		query = query.Where("reported_by_id = ?", req.ReportedByID)
	}
	if req.IsMajorIncident != nil {
		query = query.Where("is_major_incident = ?", *req.IsMajorIncident)
	}
	if req.FromDate != nil {
		query = query.Where("created_at >= ?", req.FromDate)
	}
	if req.ToDate != nil {
		query = query.Where("created_at <= ?", req.ToDate)
	}
	if req.Search != "" {
		searchPattern := "%" + req.Search + "%"
		query = query.Where("title ILIKE ? OR description ILIKE ? OR incident_number ILIKE ?",
			searchPattern, searchPattern, searchPattern)
	}
	
	// Count total
	var total int64
	if err := query.Count(&total).Error; err != nil {
		return nil, fmt.Errorf("failed to count incidents: %w", err)
	}
	
	// Apply sorting
	sortBy := "created_at"
	if req.SortBy != "" {
		sortBy = req.SortBy
	}
	sortOrder := "DESC"
	if req.SortOrder == "asc" {
		sortOrder = "ASC"
	}
	query = query.Order(fmt.Sprintf("%s %s", sortBy, sortOrder))
	
	// Apply pagination
	offset := (req.Page - 1) * req.PerPage
	query = query.Offset(offset).Limit(req.PerPage)
	
	// Execute query
	var incidents []*models.Incident
	if err := query.Find(&incidents).Error; err != nil {
		return nil, fmt.Errorf("failed to list incidents: %w", err)
	}
	
	// Calculate total pages
	totalPages := int(total) / req.PerPage
	if int(total)%req.PerPage > 0 {
		totalPages++
	}
	
	return &models.IncidentListResponse{
		Incidents:  incidents,
		Total:      total,
		Page:       req.Page,
		PerPage:    req.PerPage,
		TotalPages: totalPages,
	}, nil
}

// UpdateStatus updates the status of an incident
func (r *IncidentRepository) UpdateStatus(id uint, status models.IncidentStatus) error {
	incident, err := r.GetByID(id)
	if err != nil {
		return err
	}
	
	oldStatus := incident.Status
	incident.Status = status
	
	// Update status timestamps
	now := time.Now()
	switch status {
	case models.IncidentStatusAssigned:
		incident.AssignedAt = &now
	case models.IncidentStatusInProgress:
		incident.InProgressAt = &now
	case models.IncidentStatusResolved:
		incident.ResolvedAt = &now
	case models.IncidentStatusClosed:
		incident.ClosedAt = &now
	}
	
	// Start transaction
	tx := r.db.Begin()
	
	if err := tx.Save(incident).Error; err != nil {
		tx.Rollback()
		return fmt.Errorf("failed to update status: %w", err)
	}
	
	// Add history entry
	history := &models.IncidentHistory{
		IncidentID: id,
		FieldName:  "status",
		OldValue:   string(oldStatus),
		NewValue:   string(status),
		ChangeType: "status_change",
	}
	
	if err := tx.Create(history).Error; err != nil {
		tx.Rollback()
		return fmt.Errorf("failed to create history: %w", err)
	}
	
	return tx.Commit().Error
}

// AssignTo assigns an incident to a user and/or group
func (r *IncidentRepository) AssignTo(id uint, userID uint, groupID *uint) error {
	incident, err := r.GetByID(id)
	if err != nil {
		return err
	}
	
	incident.AssignedToID = &userID
	incident.AssignmentGroupID = groupID
	now := time.Now()
	incident.AssignedAt = &now
	
	if incident.Status == models.IncidentStatusNew {
		incident.Status = models.IncidentStatusAssigned
	}
	
	return r.Update(incident)
}

// Escalate escalates an incident
func (r *IncidentRepository) Escalate(id uint, level int) error {
	incident, err := r.GetByID(id)
	if err != nil {
		return err
	}
	
	incident.EscalationLevel = level
	
	// Add history entry
	tx := r.db.Begin()
	
	if err := tx.Save(incident).Error; err != nil {
		tx.Rollback()
		return fmt.Errorf("failed to escalate incident: %w", err)
	}
	
	history := &models.IncidentHistory{
		IncidentID: id,
		FieldName:  "escalation_level",
		OldValue:   fmt.Sprintf("%d", incident.EscalationLevel),
		NewValue:   fmt.Sprintf("%d", level),
		ChangeType: "escalation",
	}
	
	if err := tx.Create(history).Error; err != nil {
		tx.Rollback()
		return fmt.Errorf("failed to create history: %w", err)
	}
	
	return tx.Commit().Error
}

// LinkToTicket links an incident to a ticket
func (r *IncidentRepository) LinkToTicket(incidentID uint, ticketID uint) error {
	return r.db.Model(&models.Incident{}).
		Where("id = ?", incidentID).
		Update("related_ticket_id", ticketID).Error
}

// LinkToProblem links an incident to a problem
func (r *IncidentRepository) LinkToProblem(incidentID uint, problemID uint) error {
	return r.db.Model(&models.Incident{}).
		Where("id = ?", incidentID).
		Update("problem_id", problemID).Error
}

// LinkToCI links an incident to a configuration item
func (r *IncidentRepository) LinkToCI(incidentID uint, ciID uint) error {
	return r.db.Model(&models.Incident{}).
		Where("id = ?", incidentID).
		Update("configuration_item_id", ciID).Error
}

// GetRelatedIncidents gets incidents related to a specific incident
func (r *IncidentRepository) GetRelatedIncidents(id uint) ([]*models.Incident, error) {
	incident, err := r.GetByID(id)
	if err != nil {
		return nil, err
	}
	
	var related []*models.Incident
	
	// Find incidents with same problem
	if incident.ProblemID != nil {
		if err := r.db.Where("problem_id = ? AND id != ?", incident.ProblemID, id).
			Find(&related).Error; err != nil {
			return nil, fmt.Errorf("failed to get related incidents: %w", err)
		}
	}
	
	// Find incidents with same CI
	if incident.ConfigurationItemID != nil {
		var ciRelated []*models.Incident
		if err := r.db.Where("configuration_item_id = ? AND id != ?", 
			incident.ConfigurationItemID, id).
			Find(&ciRelated).Error; err != nil {
			return nil, fmt.Errorf("failed to get CI related incidents: %w", err)
		}
		related = append(related, ciRelated...)
	}
	
	return related, nil
}

// AddComment adds a comment to an incident
func (r *IncidentRepository) AddComment(comment *models.IncidentComment) error {
	if comment == nil || comment.IncidentID == 0 {
		return fmt.Errorf("invalid comment")
	}
	
	return r.db.Create(comment).Error
}

// GetComments retrieves all comments for an incident
func (r *IncidentRepository) GetComments(incidentID uint) ([]*models.IncidentComment, error) {
	var comments []*models.IncidentComment
	err := r.db.Where("incident_id = ?", incidentID).
		Preload("Author").
		Order("created_at DESC").
		Find(&comments).Error
	
	if err != nil {
		return nil, fmt.Errorf("failed to get comments: %w", err)
	}
	
	return comments, nil
}

// AddAttachment adds an attachment to an incident
func (r *IncidentRepository) AddAttachment(attachment *models.IncidentAttachment) error {
	if attachment == nil || attachment.IncidentID == 0 {
		return fmt.Errorf("invalid attachment")
	}
	
	return r.db.Create(attachment).Error
}

// GetAttachments retrieves all attachments for an incident
func (r *IncidentRepository) GetAttachments(incidentID uint) ([]*models.IncidentAttachment, error) {
	var attachments []*models.IncidentAttachment
	err := r.db.Where("incident_id = ?", incidentID).
		Preload("UploadedBy").
		Order("created_at DESC").
		Find(&attachments).Error
	
	if err != nil {
		return nil, fmt.Errorf("failed to get attachments: %w", err)
	}
	
	return attachments, nil
}

// DeleteAttachment deletes an attachment
func (r *IncidentRepository) DeleteAttachment(id uint) error {
	return r.db.Delete(&models.IncidentAttachment{}, id).Error
}

// AddHistory adds a history entry for an incident
func (r *IncidentRepository) AddHistory(history *models.IncidentHistory) error {
	if history == nil || history.IncidentID == 0 {
		return fmt.Errorf("invalid history")
	}
	
	return r.db.Create(history).Error
}

// GetHistory retrieves the history for an incident
func (r *IncidentRepository) GetHistory(incidentID uint) ([]*models.IncidentHistory, error) {
	var history []*models.IncidentHistory
	err := r.db.Where("incident_id = ?", incidentID).
		Preload("ChangedBy").
		Order("created_at DESC").
		Find(&history).Error
	
	if err != nil {
		return nil, fmt.Errorf("failed to get history: %w", err)
	}
	
	return history, nil
}

// Helper methods

// generateIncidentNumber generates a unique incident number
func (r *IncidentRepository) generateIncidentNumber() string {
	// Format: INC-YYYYMMDD-XXXXX
	now := time.Now()
	dateStr := now.Format("20060102")
	
	// Get count of incidents created today
	var count int64
	r.db.Model(&models.Incident{}).
		Where("DATE(created_at) = DATE(?)", now).
		Count(&count)
	
	return fmt.Sprintf("INC-%s-%05d", dateStr, count+1)
}

// updateMetrics updates incident metrics based on status changes
func (r *IncidentRepository) updateMetrics(incident *models.Incident, original *models.Incident) {
	now := time.Now()
	
	// Update time to respond
	if original.Status == models.IncidentStatusNew && 
	   incident.Status == models.IncidentStatusAssigned {
		minutes := int(now.Sub(incident.ReportedAt).Minutes())
		incident.TimeToRespond = &minutes
		
		// Check SLA compliance
		if incident.ResponseDue != nil {
			incident.ResponseMet = now.Before(*incident.ResponseDue)
		}
	}
	
	// Update time to resolve
	if incident.Status == models.IncidentStatusResolved &&
	   original.Status != models.IncidentStatusResolved {
		minutes := int(now.Sub(incident.ReportedAt).Minutes())
		incident.TimeToResolve = &minutes
		
		// Check SLA compliance
		if incident.ResolutionDue != nil {
			incident.ResolutionMet = now.Before(*incident.ResolutionDue)
		}
	}
	
	// Track reopens
	if original.Status == models.IncidentStatusClosed &&
	   incident.Status != models.IncidentStatusClosed {
		incident.ReopenCount++
	}
}

// Metrics structures

// IncidentMetrics represents incident metrics
type IncidentMetrics struct {
	TotalIncidents      int64
	OpenIncidents       int64
	ResolvedIncidents   int64
	AverageTimeToResolve float64
	AverageTimeToRespond float64
	ByPriority          map[int]int64
	BySeverity          map[string]int64
	ByCategory          map[string]int64
}

// GetMetrics retrieves incident metrics for a time period
func (r *IncidentRepository) GetMetrics(from, to time.Time) (*IncidentMetrics, error) {
	metrics := &IncidentMetrics{
		ByPriority: make(map[int]int64),
		BySeverity: make(map[string]int64),
		ByCategory: make(map[string]int64),
	}
	
	// Total incidents
	r.db.Model(&models.Incident{}).
		Where("created_at BETWEEN ? AND ?", from, to).
		Count(&metrics.TotalIncidents)
	
	// Open incidents
	r.db.Model(&models.Incident{}).
		Where("created_at BETWEEN ? AND ?", from, to).
		Where("status NOT IN ?", []string{"resolved", "closed"}).
		Count(&metrics.OpenIncidents)
	
	// Resolved incidents
	r.db.Model(&models.Incident{}).
		Where("resolved_at BETWEEN ? AND ?", from, to).
		Count(&metrics.ResolvedIncidents)
	
	// Average resolution time
	var avgResolve float64
	r.db.Model(&models.Incident{}).
		Where("resolved_at BETWEEN ? AND ?", from, to).
		Where("time_to_resolve IS NOT NULL").
		Select("AVG(time_to_resolve)").
		Scan(&avgResolve)
	metrics.AverageTimeToResolve = avgResolve
	
	// Average response time
	var avgRespond float64
	r.db.Model(&models.Incident{}).
		Where("assigned_at BETWEEN ? AND ?", from, to).
		Where("time_to_respond IS NOT NULL").
		Select("AVG(time_to_respond)").
		Scan(&avgRespond)
	metrics.AverageTimeToRespond = avgRespond
	
	// By priority
	rows, _ := r.db.Model(&models.Incident{}).
		Where("created_at BETWEEN ? AND ?", from, to).
		Select("priority, COUNT(*) as count").
		Group("priority").
		Rows()
	defer rows.Close()
	
	for rows.Next() {
		var priority int
		var count int64
		rows.Scan(&priority, &count)
		metrics.ByPriority[priority] = count
	}
	
	// By severity
	rows2, _ := r.db.Model(&models.Incident{}).
		Where("created_at BETWEEN ? AND ?", from, to).
		Select("severity, COUNT(*) as count").
		Group("severity").
		Rows()
	defer rows2.Close()
	
	for rows2.Next() {
		var severity string
		var count int64
		rows2.Scan(&severity, &count)
		metrics.BySeverity[severity] = count
	}
	
	// By category
	rows3, _ := r.db.Model(&models.Incident{}).
		Where("created_at BETWEEN ? AND ?", from, to).
		Select("category, COUNT(*) as count").
		Group("category").
		Rows()
	defer rows3.Close()
	
	for rows3.Next() {
		var category string
		var count int64
		rows3.Scan(&category, &count)
		metrics.ByCategory[category] = count
	}
	
	return metrics, nil
}

// SLAMetrics represents SLA compliance metrics
type SLAMetrics struct {
	TotalWithSLA        int64
	ResponseMet         int64
	ResolutionMet       int64
	ResponseCompliance  float64
	ResolutionCompliance float64
}

// GetSLACompliance retrieves SLA compliance metrics
func (r *IncidentRepository) GetSLACompliance(from, to time.Time) (*SLAMetrics, error) {
	metrics := &SLAMetrics{}
	
	// Total incidents with SLA
	r.db.Model(&models.Incident{}).
		Where("created_at BETWEEN ? AND ?", from, to).
		Where("response_due IS NOT NULL OR resolution_due IS NOT NULL").
		Count(&metrics.TotalWithSLA)
	
	// Response SLA met
	r.db.Model(&models.Incident{}).
		Where("created_at BETWEEN ? AND ?", from, to).
		Where("response_due IS NOT NULL AND response_met = ?", true).
		Count(&metrics.ResponseMet)
	
	// Resolution SLA met
	r.db.Model(&models.Incident{}).
		Where("created_at BETWEEN ? AND ?", from, to).
		Where("resolution_due IS NOT NULL AND resolution_met = ?", true).
		Count(&metrics.ResolutionMet)
	
	// Calculate compliance percentages
	if metrics.TotalWithSLA > 0 {
		metrics.ResponseCompliance = float64(metrics.ResponseMet) / float64(metrics.TotalWithSLA) * 100
		metrics.ResolutionCompliance = float64(metrics.ResolutionMet) / float64(metrics.TotalWithSLA) * 100
	}
	
	return metrics, nil
}

// TrendAnalysis represents trend analysis data
type TrendAnalysis struct {
	Period      string
	DataPoints  []TrendDataPoint
	Growth      float64
	Prediction  float64
}

// TrendDataPoint represents a single data point in trend analysis
type TrendDataPoint struct {
	Date  time.Time
	Count int64
}

// GetTrendAnalysis performs trend analysis on incident data
func (r *IncidentRepository) GetTrendAnalysis(period string) (*TrendAnalysis, error) {
	analysis := &TrendAnalysis{
		Period:     period,
		DataPoints: []TrendDataPoint{},
	}
	
	// Determine date range based on period
	now := time.Now()
	var from time.Time
	var groupBy string
	
	switch period {
	case "week":
		from = now.AddDate(0, 0, -7)
		groupBy = "DATE(created_at)"
	case "month":
		from = now.AddDate(0, -1, 0)
		groupBy = "DATE(created_at)"
	case "quarter":
		from = now.AddDate(0, -3, 0)
		groupBy = "DATE_TRUNC('week', created_at)"
	case "year":
		from = now.AddDate(-1, 0, 0)
		groupBy = "DATE_TRUNC('month', created_at)"
	default:
		from = now.AddDate(0, -1, 0)
		groupBy = "DATE(created_at)"
	}
	
	// Get data points
	rows, err := r.db.Model(&models.Incident{}).
		Where("created_at >= ?", from).
		Select(groupBy + " as date, COUNT(*) as count").
		Group(groupBy).
		Order("date").
		Rows()
	
	if err != nil {
		return nil, fmt.Errorf("failed to get trend data: %w", err)
	}
	defer rows.Close()
	
	var firstCount, lastCount int64
	for rows.Next() {
		var point TrendDataPoint
		rows.Scan(&point.Date, &point.Count)
		analysis.DataPoints = append(analysis.DataPoints, point)
		
		if firstCount == 0 {
			firstCount = point.Count
		}
		lastCount = point.Count
	}
	
	// Calculate growth
	if firstCount > 0 {
		analysis.Growth = ((float64(lastCount) - float64(firstCount)) / float64(firstCount)) * 100
	}
	
	// Simple linear prediction (just for demonstration)
	if len(analysis.DataPoints) > 1 {
		avgDailyIncrease := float64(lastCount-firstCount) / float64(len(analysis.DataPoints))
		analysis.Prediction = float64(lastCount) + avgDailyIncrease*7
	}
	
	return analysis, nil
}