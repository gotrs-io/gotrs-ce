apiVersion: v1
kind: ConfigMap
metadata:
  name: cdn-config
  namespace: default
data:
  cdn.conf: |
    # CDN configuration for static assets
    # This config can be used with CloudFront, Cloudflare, or any CDN

    # Cache Control Headers
    cache_control:
      # Images - cache for 1 year
      images:
        pattern: '\.(jpg|jpeg|png|gif|ico|svg|webp)$'
        max_age: 31536000
        s_maxage: 31536000
        immutable: true

      # CSS/JS - cache for 1 month with revalidation
      assets:
        pattern: '\.(css|js)$'
        max_age: 2592000
        s_maxage: 2592000
        must_revalidate: true
        stale_while_revalidate: 86400

      # Fonts - cache for 1 year
      fonts:
        pattern: '\.(woff|woff2|ttf|eot|otf)$'
        max_age: 31536000
        s_maxage: 31536000
        immutable: true

      # Documents - cache for 1 day
      documents:
        pattern: '\.(pdf|doc|docx|xls|xlsx)$'
        max_age: 86400
        s_maxage: 86400
        must_revalidate: true

    # CORS Configuration
    cors:
      enabled: true
      allowed_origins:
        - https://gotrs.local
        - https://*.gotrs.local
      allowed_methods:
        - GET
        - HEAD
        - OPTIONS
      allowed_headers:
        - Content-Type
        - Range
      exposed_headers:
        - Content-Length
        - Content-Range
      max_age: 86400

    # Compression
    compression:
      enabled: true
      types:
        - text/plain
        - text/css
        - text/javascript
        - application/javascript
        - application/json
        - application/xml
        - image/svg+xml
      min_length: 1024

    # Security Headers
    security:
      x_content_type_options: nosniff
      x_frame_options: SAMEORIGIN
      x_xss_protection: "1; mode=block"
      referrer_policy: strict-origin-when-cross-origin
      content_security_policy: "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'"

    # URL Rewriting
    rewrites:
      # Version assets with query strings
      - pattern: '/static/v([0-9]+)/(.*)'
        replacement: '/static/$2?v=$1'

      # WebP fallback
      - pattern: '(.*)\.webp$'
        replacement: '$1.jpg'
        condition: 'no_webp_support'

    # Edge Functions
    edge_functions:
      # Image optimization
      image_optimization:
        enabled: true
        formats:
          - webp
          - avif
        quality: 85
        resize_options:
          - width: 320
            suffix: "-sm"
          - width: 768
            suffix: "-md"
          - width: 1024
            suffix: "-lg"
          - width: 1920
            suffix: "-xl"

      # Geolocation-based routing
      geo_routing:
        enabled: false
        rules:
          - country: US
            origin: us-east-1.gotrs.local
          - country: EU
            origin: eu-west-1.gotrs.local
          - country: ASIA
            origin: ap-southeast-1.gotrs.local
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: cloudfront-config
  namespace: default
data:
  distribution.json: |
    {
      "CallerReference": "gotrs-cdn-${TIMESTAMP}",
      "Comment": "GOTRS CDN Distribution",
      "Enabled": true,
      "Origins": {
        "Quantity": 1,
        "Items": [
          {
            "Id": "gotrs-origin",
            "DomainName": "origin.gotrs.local",
            "CustomOriginConfig": {
              "HTTPPort": 80,
              "HTTPSPort": 443,
              "OriginProtocolPolicy": "https-only",
              "OriginSslProtocols": {
                "Quantity": 3,
                "Items": ["TLSv1", "TLSv1.1", "TLSv1.2"]
              }
            },
            "CustomHeaders": {
              "Quantity": 1,
              "Items": [
                {
                  "HeaderName": "X-CDN-Secret",
                  "HeaderValue": "${CDN_SECRET}"
                }
              ]
            }
          }
        ]
      },
      "DefaultCacheBehavior": {
        "TargetOriginId": "gotrs-origin",
        "ViewerProtocolPolicy": "redirect-to-https",
        "AllowedMethods": {
          "Quantity": 3,
          "Items": ["GET", "HEAD", "OPTIONS"],
          "CachedMethods": {
            "Quantity": 2,
            "Items": ["GET", "HEAD"]
          }
        },
        "Compress": true,
        "MinTTL": 0,
        "DefaultTTL": 86400,
        "MaxTTL": 31536000,
        "ForwardedValues": {
          "QueryString": false,
          "Cookies": {
            "Forward": "none"
          },
          "Headers": {
            "Quantity": 3,
            "Items": ["CloudFront-Viewer-Country", "CloudFront-Is-Mobile-Viewer", "CloudFront-Is-Desktop-Viewer"]
          }
        },
        "TrustedSigners": {
          "Enabled": false,
          "Quantity": 0
        }
      },
      "CacheBehaviors": {
        "Quantity": 3,
        "Items": [
          {
            "PathPattern": "/static/*",
            "TargetOriginId": "gotrs-origin",
            "ViewerProtocolPolicy": "https-only",
            "MinTTL": 2592000,
            "DefaultTTL": 2592000,
            "MaxTTL": 31536000,
            "Compress": true,
            "ForwardedValues": {
              "QueryString": true,
              "QueryStringCacheKeys": {
                "Quantity": 1,
                "Items": ["v"]
              },
              "Cookies": {
                "Forward": "none"
              }
            }
          },
          {
            "PathPattern": "/api/*",
            "TargetOriginId": "gotrs-origin",
            "ViewerProtocolPolicy": "https-only",
            "MinTTL": 0,
            "DefaultTTL": 0,
            "MaxTTL": 0,
            "AllowedMethods": {
              "Quantity": 7,
              "Items": ["GET", "HEAD", "OPTIONS", "PUT", "POST", "PATCH", "DELETE"],
              "CachedMethods": {
                "Quantity": 2,
                "Items": ["GET", "HEAD"]
              }
            },
            "ForwardedValues": {
              "QueryString": true,
              "Cookies": {
                "Forward": "all"
              },
              "Headers": {
                "Quantity": 4,
                "Items": ["Authorization", "Content-Type", "Accept", "X-Request-Id"]
              }
            }
          },
          {
            "PathPattern": "/ws/*",
            "TargetOriginId": "gotrs-origin",
            "ViewerProtocolPolicy": "https-only",
            "MinTTL": 0,
            "DefaultTTL": 0,
            "MaxTTL": 0,
            "ForwardedValues": {
              "QueryString": true,
              "Cookies": {
                "Forward": "all"
              },
              "Headers": {
                "Quantity": 5,
                "Items": ["Upgrade", "Connection", "Sec-WebSocket-Key", "Sec-WebSocket-Version", "Authorization"]
              }
            }
          }
        ]
      },
      "CustomErrorResponses": {
        "Quantity": 2,
        "Items": [
          {
            "ErrorCode": 404,
            "ResponsePagePath": "/error/404.html",
            "ResponseCode": "404",
            "ErrorCachingMinTTL": 300
          },
          {
            "ErrorCode": 503,
            "ResponsePagePath": "/error/503.html",
            "ResponseCode": "503",
            "ErrorCachingMinTTL": 60
          }
        ]
      },
      "PriceClass": "PriceClass_100",
      "ViewerCertificate": {
        "CloudFrontDefaultCertificate": false,
        "ACMCertificateArn": "${ACM_CERTIFICATE_ARN}",
        "SSLSupportMethod": "sni-only",
        "MinimumProtocolVersion": "TLSv1.2_2021"
      },
      "Logging": {
        "Enabled": true,
        "IncludeCookies": false,
        "Bucket": "gotrs-cdn-logs.s3.amazonaws.com",
        "Prefix": "cloudfront/"
      },
      "WebACLId": "${WAF_WEB_ACL_ID}"
    }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: varnish-config
  namespace: default
data:
  default.vcl: |
    vcl 4.1;

    import std;
    import directors;

    # Backend configuration
    backend default {
        .host = "nginx-lb.default.svc.cluster.local";
        .port = "80";
        .probe = {
            .url = "/health";
            .interval = 5s;
            .timeout = 2s;
            .window = 5;
            .threshold = 3;
        }
    }

    # Additional backends for load balancing
    backend backend1 {
        .host = "nginx-lb-1.default.svc.cluster.local";
        .port = "80";
    }

    backend backend2 {
        .host = "nginx-lb-2.default.svc.cluster.local";
        .port = "80";
    }

    # Initialize directors for load balancing
    sub vcl_init {
        new vdir = directors.round_robin();
        vdir.add_backend(default);
        vdir.add_backend(backend1);
        vdir.add_backend(backend2);
    }

    # Client request handling
    sub vcl_recv {
        # Set backend
        set req.backend_hint = vdir.backend();

        # Normalize URL
        set req.url = std.querysort(req.url);

        # Remove tracking parameters
        if (req.url ~ "(\?|&)(utm_source|utm_medium|utm_campaign|utm_content|gclid|fbclid)=") {
            set req.url = regsuball(req.url, "(utm_source|utm_medium|utm_campaign|utm_content|gclid|fbclid)=[^&]+&?", "");
            set req.url = regsub(req.url, "(\?|&)$", "");
        }

        # Handle WebSocket upgrades
        if (req.http.Upgrade ~ "(?i)websocket") {
            return (pipe);
        }

        # Bypass cache for authenticated requests
        if (req.http.Authorization || req.http.Cookie ~ "session=") {
            return (pass);
        }

        # Bypass cache for POST, PUT, DELETE
        if (req.method != "GET" && req.method != "HEAD") {
            return (pass);
        }

        # Cache static files
        if (req.url ~ "\.(jpg|jpeg|png|gif|ico|css|js|svg|woff|woff2|ttf|eot|otf)(\?|$)") {
            unset req.http.Cookie;
            return (hash);
        }

        # Cache API responses for GET requests
        if (req.url ~ "^/api/v1/(queues|templates|config)") {
            return (hash);
        }

        # Pass everything else
        return (pass);
    }

    # Backend response handling
    sub vcl_backend_response {
        # Enable grace mode
        set beresp.grace = 6h;

        # Set cache times for static content
        if (bereq.url ~ "\.(jpg|jpeg|png|gif|ico|svg|woff|woff2|ttf|eot|otf)(\?|$)") {
            unset beresp.http.Set-Cookie;
            set beresp.ttl = 365d;
            set beresp.http.Cache-Control = "public, max-age=31536000, immutable";
        }

        # CSS and JS with version strings
        if (bereq.url ~ "\.(css|js)(\?v=|$)") {
            unset beresp.http.Set-Cookie;
            set beresp.ttl = 30d;
            set beresp.http.Cache-Control = "public, max-age=2592000";
        }

        # Cache successful API responses
        if (bereq.url ~ "^/api/v1/" && beresp.status == 200) {
            set beresp.ttl = 60s;
            set beresp.http.Cache-Control = "public, max-age=60, s-maxage=60";
        }

        # Don't cache error responses
        if (beresp.status >= 400) {
            set beresp.ttl = 0s;
            set beresp.uncacheable = true;
            return (deliver);
        }

        # Enable ESI processing
        if (beresp.http.Surrogate-Control ~ "ESI/1.0") {
            unset beresp.http.Surrogate-Control;
            set beresp.do_esi = true;
        }
    }

    # Delivery
    sub vcl_deliver {
        # Add cache hit/miss header
        if (obj.hits > 0) {
            set resp.http.X-Cache = "HIT";
            set resp.http.X-Cache-Hits = obj.hits;
        } else {
            set resp.http.X-Cache = "MISS";
        }

        # Security headers
        set resp.http.X-Frame-Options = "SAMEORIGIN";
        set resp.http.X-Content-Type-Options = "nosniff";
        set resp.http.X-XSS-Protection = "1; mode=block";
        set resp.http.Referrer-Policy = "strict-origin-when-cross-origin";

        # Remove internal headers
        unset resp.http.X-Powered-By;
        unset resp.http.Server;
        unset resp.http.Via;
        unset resp.http.X-Varnish;
    }

    # Hash calculation
    sub vcl_hash {
        hash_data(req.url);

        if (req.http.host) {
            hash_data(req.http.host);
        } else {
            hash_data(server.ip);
        }

        # Vary cache by device type for responsive content
        if (req.http.User-Agent ~ "Mobile|Android|iPhone") {
            hash_data("mobile");
        } else {
            hash_data("desktop");
        }

        return (lookup);
    }

    # Purge handling
    sub vcl_purge {
        return (synth(200, "Purged"));
    }

    # Error handling
    sub vcl_backend_error {
        set beresp.http.Content-Type = "text/html; charset=utf-8";
        set beresp.ttl = 10s;

        synthetic({"
            <!DOCTYPE html>
            <html>
            <head>
                <title>Service Temporarily Unavailable</title>
            </head>
            <body>
                <h1>Service Temporarily Unavailable</h1>
                <p>The server is temporarily unable to service your request. Please try again later.</p>
            </body>
            </html>
        "});

        return (deliver);
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: varnish-cache
  labels:
    app: varnish-cache
    component: cache
spec:
  replicas: 2
  selector:
    matchLabels:
      app: varnish-cache
  template:
    metadata:
      labels:
        app: varnish-cache
        version: v1
    spec:
      containers:
      - name: varnish
        image: varnish:7-alpine
        args:
        - varnishd
        - -F
        - -f
        - /etc/varnish/default.vcl
        - -s
        - malloc,512M
        - -a
        - :80
        - -T
        - :6082
        ports:
        - name: http
          containerPort: 80
          protocol: TCP
        - name: admin
          containerPort: 6082
          protocol: TCP
        volumeMounts:
        - name: varnish-config
          mountPath: /etc/varnish
          readOnly: true
        resources:
          requests:
            memory: "768Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 80
            httpHeaders:
            - name: Host
              value: health.local
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 80
            httpHeaders:
            - name: Host
              value: health.local
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: varnish-config
        configMap:
          name: varnish-config
---
apiVersion: v1
kind: Service
metadata:
  name: varnish-cache
  labels:
    app: varnish-cache
spec:
  type: ClusterIP
  selector:
    app: varnish-cache
  ports:
  - name: http
    port: 80
    targetPort: http
    protocol: TCP
  - name: admin
    port: 6082
    targetPort: admin
    protocol: TCP
