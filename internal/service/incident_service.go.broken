package service

import (
	"fmt"
	"strings"
	"time"

	"github.com/gotrs-io/gotrs-ce/internal/models"
	"github.com/gotrs-io/gotrs-ce/internal/repository"
)

// IIncidentService defines the interface for incident service
type IIncidentService interface {
	// CRUD operations
	CreateIncident(incident *models.Incident, userID uint) (*models.Incident, error)
	GetIncident(id uint) (*models.Incident, error)
	GetIncidentByNumber(number string) (*models.Incident, error)
	UpdateIncident(incident *models.Incident, userID uint) error
	DeleteIncident(id uint) error
	ListIncidents(req *models.IncidentListRequest) (*models.IncidentListResponse, error)
	
	// Workflow operations
	AssignIncident(id uint, assigneeID uint, groupID *uint, userID uint) error
	UpdateIncidentStatus(id uint, status models.IncidentStatus, userID uint) error
	EscalateIncident(id uint, level int, reason string, userID uint) error
	ResolveIncident(id uint, resolutionCode, resolutionNotes string, userID uint) error
	ReopenIncident(id uint, reason string, userID uint) error
	
	// Relationship operations
	LinkToTicket(incidentID uint, ticketID uint) error
	LinkToProblem(incidentID uint, problemID uint) error
	LinkToCI(incidentID uint, ciID uint) error
	LinkToService(incidentID uint, serviceID uint) error
	GetRelatedIncidents(id uint) ([]*models.Incident, error)
	CreateChildIncident(parentID uint, incident *models.Incident, userID uint) (*models.Incident, error)
	
	// Communication operations
	AddComment(incidentID uint, comment string, isPublic bool, userID uint) error
	AddWorkNote(incidentID uint, note string, userID uint) error
	GetComments(incidentID uint) ([]*models.IncidentComment, error)
	NotifyStakeholders(incidentID uint, message string) error
	
	// Attachment operations
	AddAttachment(incidentID uint, fileName, filePath string, fileSize int64, contentType string, userID uint) error
	GetAttachments(incidentID uint) ([]*models.IncidentAttachment, error)
	DeleteAttachment(attachmentID uint) error
	
	// History and audit
	GetHistory(incidentID uint) ([]*models.IncidentHistory, error)
	GetAuditTrail(incidentID uint) ([]AuditEntry, error)
	
	// SLA operations
	CalculateSLA(incident *models.Incident) error
	CheckSLACompliance(incidentID uint) (*SLAStatus, error)
	UpdateSLATimes(incidentID uint) error
	
	// Analytics and reporting
	GetIncidentMetrics(from, to time.Time) (*repository.IncidentMetrics, error)
	GetSLACompliance(from, to time.Time) (*repository.SLAMetrics, error)
	GetTrendAnalysis(period string) (*repository.TrendAnalysis, error)
	GenerateIncidentReport(incidentID uint) (*IncidentReport, error)
	
	// Major incident management
	DeclareMajorIncident(incidentID uint, userID uint) error
	CreateWarRoom(incidentID uint) (*WarRoom, error)
	UpdateIncidentPriority(incidentID uint, impact, urgency int, userID uint) error
	
	// Automation
	ApplyAutomationRules(incident *models.Incident) error
	TriggerWorkflow(incidentID uint, workflowName string) error
}

// IncidentService implements the incident service
type IncidentService struct {
	incidentRepo repository.IIncidentRepository
	userRepo     repository.IUserRepository
	ticketRepo   repository.ITicketRepository
	slaService   ISLAService
	emailService IEmailService
	workflowSvc  IWorkflowService
}

// NewIncidentService creates a new incident service
func NewIncidentService(
	incidentRepo repository.IIncidentRepository,
	userRepo repository.IUserRepository,
	ticketRepo repository.ITicketRepository,
) IIncidentService {
	return &IncidentService{
		incidentRepo: incidentRepo,
		userRepo:     userRepo,
		ticketRepo:   ticketRepo,
	}
}

// CreateIncident creates a new incident
func (s *IncidentService) CreateIncident(incident *models.Incident, userID uint) (*models.Incident, error) {
	if incident == nil {
		return nil, fmt.Errorf("incident cannot be nil")
	}
	
	// Validate required fields
	if incident.Title == "" {
		return nil, fmt.Errorf("incident title is required")
	}
	
	// Set creator
	incident.CreatedByID = userID
	incident.ReportedByID = userID
	
	// Set default values
	if incident.Status == "" {
		incident.Status = models.IncidentStatusNew
	}
	if incident.Severity == "" {
		incident.Severity = models.SeverityMedium
	}
	if incident.Category == "" {
		incident.Category = models.CategoryOther
	}
	if incident.Impact == 0 {
		incident.Impact = 2
	}
	if incident.Urgency == 0 {
		incident.Urgency = 2
	}
	
	// Calculate priority
	incident.CalculatePriority()
	
	// Calculate SLA times
	if err := s.CalculateSLA(incident); err != nil {
		return nil, fmt.Errorf("failed to calculate SLA: %w", err)
	}
	
	// Create the incident
	if err := s.incidentRepo.Create(incident); err != nil {
		return nil, fmt.Errorf("failed to create incident: %w", err)
	}
	
	// Apply automation rules
	if err := s.ApplyAutomationRules(incident); err != nil {
		// Log error but don't fail the creation
		fmt.Printf("Warning: Failed to apply automation rules: %v\n", err)
	}
	
	// Send notifications
	go s.sendIncidentCreatedNotifications(incident)
	
	return incident, nil
}

// GetIncident retrieves an incident by ID
func (s *IncidentService) GetIncident(id uint) (*models.Incident, error) {
	return s.incidentRepo.GetByID(id)
}

// GetIncidentByNumber retrieves an incident by number
func (s *IncidentService) GetIncidentByNumber(number string) (*models.Incident, error) {
	return s.incidentRepo.GetByNumber(number)
}

// UpdateIncident updates an existing incident
func (s *IncidentService) UpdateIncident(incident *models.Incident, userID uint) error {
	if incident == nil || incident.ID == 0 {
		return fmt.Errorf("invalid incident")
	}
	
	// Set last modified by
	incident.LastModifiedByID = &userID
	
	// Recalculate priority if impact or urgency changed
	incident.CalculatePriority()
	
	// Update SLA times if needed
	if err := s.UpdateSLATimes(incident.ID); err != nil {
		return fmt.Errorf("failed to update SLA times: %w", err)
	}
	
	// Update the incident
	if err := s.incidentRepo.Update(incident); err != nil {
		return fmt.Errorf("failed to update incident: %w", err)
	}
	
	// Apply automation rules
	if err := s.ApplyAutomationRules(incident); err != nil {
		fmt.Printf("Warning: Failed to apply automation rules: %v\n", err)
	}
	
	return nil
}

// DeleteIncident deletes an incident
func (s *IncidentService) DeleteIncident(id uint) error {
	return s.incidentRepo.Delete(id)
}

// ListIncidents lists incidents with filtering and pagination
func (s *IncidentService) ListIncidents(req *models.IncidentListRequest) (*models.IncidentListResponse, error) {
	return s.incidentRepo.List(req)
}

// AssignIncident assigns an incident to a user and/or group
func (s *IncidentService) AssignIncident(id uint, assigneeID uint, groupID *uint, userID uint) error {
	// Verify assignee exists
	if _, err := s.userRepo.GetByID(assigneeID); err != nil {
		return fmt.Errorf("assignee not found: %w", err)
	}
	
	// Assign the incident
	if err := s.incidentRepo.AssignTo(id, assigneeID, groupID); err != nil {
		return fmt.Errorf("failed to assign incident: %w", err)
	}
	
	// Add history entry
	history := &models.IncidentHistory{
		IncidentID:  id,
		FieldName:   "assigned_to",
		NewValue:    fmt.Sprintf("User ID: %d", assigneeID),
		ChangedByID: userID,
		ChangeType:  "assignment",
	}
	if err := s.incidentRepo.AddHistory(history); err != nil {
		fmt.Printf("Warning: Failed to add history: %v\n", err)
	}
	
	// Send notification to assignee
	go s.sendAssignmentNotification(id, assigneeID)
	
	return nil
}

// UpdateIncidentStatus updates the status of an incident
func (s *IncidentService) UpdateIncidentStatus(id uint, status models.IncidentStatus, userID uint) error {
	// Get current incident
	incident, err := s.incidentRepo.GetByID(id)
	if err != nil {
		return err
	}
	
	// Validate status transition
	if !s.isValidStatusTransition(incident.Status, status) {
		return fmt.Errorf("invalid status transition from %s to %s", incident.Status, status)
	}
	
	// Update status
	if err := s.incidentRepo.UpdateStatus(id, status); err != nil {
		return fmt.Errorf("failed to update status: %w", err)
	}
	
	// Add history entry
	history := &models.IncidentHistory{
		IncidentID:  id,
		FieldName:   "status",
		OldValue:    string(incident.Status),
		NewValue:    string(status),
		ChangedByID: userID,
		ChangeType:  "status_change",
	}
	if err := s.incidentRepo.AddHistory(history); err != nil {
		fmt.Printf("Warning: Failed to add history: %v\n", err)
	}
	
	// Send notifications based on status
	go s.sendStatusChangeNotification(id, status)
	
	return nil
}

// EscalateIncident escalates an incident
func (s *IncidentService) EscalateIncident(id uint, level int, reason string, userID uint) error {
	// Validate escalation level
	if level < 1 || level > 5 {
		return fmt.Errorf("invalid escalation level: %d", level)
	}
	
	// Escalate the incident
	if err := s.incidentRepo.Escalate(id, level); err != nil {
		return fmt.Errorf("failed to escalate incident: %w", err)
	}
	
	// Add work note about escalation
	note := fmt.Sprintf("Incident escalated to level %d. Reason: %s", level, reason)
	if err := s.AddWorkNote(id, note, userID); err != nil {
		fmt.Printf("Warning: Failed to add work note: %v\n", err)
	}
	
	// Trigger escalation workflow
	go s.TriggerWorkflow(id, "escalation")
	
	// Send escalation notifications
	go s.sendEscalationNotification(id, level, reason)
	
	return nil
}

// ResolveIncident marks an incident as resolved
func (s *IncidentService) ResolveIncident(id uint, resolutionCode, resolutionNotes string, userID uint) error {
	// Get the incident
	incident, err := s.incidentRepo.GetByID(id)
	if err != nil {
		return err
	}
	
	// Update resolution details
	incident.ResolutionCode = resolutionCode
	incident.ResolutionNotes = resolutionNotes
	incident.Status = models.IncidentStatusResolved
	now := time.Now()
	incident.ResolvedAt = &now
	
	// Calculate resolution time
	timeToResolve := incident.GetTimeToResolve()
	incident.TimeToResolve = &timeToResolve
	
	// Check SLA compliance
	if incident.ResolutionDue != nil {
		incident.ResolutionMet = now.Before(*incident.ResolutionDue)
	}
	
	// Update the incident
	if err := s.incidentRepo.Update(incident); err != nil {
		return fmt.Errorf("failed to resolve incident: %w", err)
	}
	
	// Add resolution comment
	comment := fmt.Sprintf("Incident resolved.\nResolution Code: %s\nNotes: %s", 
		resolutionCode, resolutionNotes)
	if err := s.AddComment(id, comment, true, userID); err != nil {
		fmt.Printf("Warning: Failed to add resolution comment: %v\n", err)
	}
	
	// Send resolution notifications
	go s.sendResolutionNotification(id)
	
	return nil
}

// ReopenIncident reopens a closed incident
func (s *IncidentService) ReopenIncident(id uint, reason string, userID uint) error {
	// Get the incident
	incident, err := s.incidentRepo.GetByID(id)
	if err != nil {
		return err
	}
	
	// Check if incident can be reopened
	if incident.Status != models.IncidentStatusClosed && 
	   incident.Status != models.IncidentStatusResolved {
		return fmt.Errorf("incident cannot be reopened from status: %s", incident.Status)
	}
	
	// Update status and reopen count
	incident.Status = models.IncidentStatusInProgress
	incident.ReopenCount++
	incident.ResolvedAt = nil
	incident.ClosedAt = nil
	
	// Update the incident
	if err := s.incidentRepo.Update(incident); err != nil {
		return fmt.Errorf("failed to reopen incident: %w", err)
	}
	
	// Add reopen comment
	comment := fmt.Sprintf("Incident reopened. Reason: %s\nThis is reopen #%d", 
		reason, incident.ReopenCount)
	if err := s.AddComment(id, comment, true, userID); err != nil {
		fmt.Printf("Warning: Failed to add reopen comment: %v\n", err)
	}
	
	// Send reopen notifications
	go s.sendReopenNotification(id, reason)
	
	return nil
}

// LinkToTicket links an incident to a ticket
func (s *IncidentService) LinkToTicket(incidentID uint, ticketID uint) error {
	// Verify ticket exists
	if _, err := s.ticketRepo.GetByID(ticketID); err != nil {
		return fmt.Errorf("ticket not found: %w", err)
	}
	
	return s.incidentRepo.LinkToTicket(incidentID, ticketID)
}

// LinkToProblem links an incident to a problem
func (s *IncidentService) LinkToProblem(incidentID uint, problemID uint) error {
	return s.incidentRepo.LinkToProblem(incidentID, problemID)
}

// LinkToCI links an incident to a configuration item
func (s *IncidentService) LinkToCI(incidentID uint, ciID uint) error {
	return s.incidentRepo.LinkToCI(incidentID, ciID)
}

// LinkToService links an incident to a service
func (s *IncidentService) LinkToService(incidentID uint, serviceID uint) error {
	incident, err := s.incidentRepo.GetByID(incidentID)
	if err != nil {
		return err
	}
	
	incident.ServiceID = &serviceID
	return s.incidentRepo.Update(incident)
}

// GetRelatedIncidents gets incidents related to a specific incident
func (s *IncidentService) GetRelatedIncidents(id uint) ([]*models.Incident, error) {
	return s.incidentRepo.GetRelatedIncidents(id)
}

// CreateChildIncident creates a child incident
func (s *IncidentService) CreateChildIncident(parentID uint, incident *models.Incident, userID uint) (*models.Incident, error) {
	// Get parent incident
	parent, err := s.incidentRepo.GetByID(parentID)
	if err != nil {
		return nil, fmt.Errorf("parent incident not found: %w", err)
	}
	
	// Inherit properties from parent
	if incident.Category == "" {
		incident.Category = parent.Category
	}
	if incident.Severity == "" {
		incident.Severity = parent.Severity
	}
	if incident.ServiceID == nil {
		incident.ServiceID = parent.ServiceID
	}
	if incident.ConfigurationItemID == nil {
		incident.ConfigurationItemID = parent.ConfigurationItemID
	}
	
	// Create the incident
	child, err := s.CreateIncident(incident, userID)
	if err != nil {
		return nil, err
	}
	
	// Create relationship
	relation := &models.IncidentRelation{
		IncidentID:   parentID,
		RelatedID:    child.ID,
		RelationType: "parent",
	}
	
	// Note: Would need to add this to repository
	// s.incidentRepo.AddRelation(relation)
	
	return child, nil
}

// AddComment adds a comment to an incident
func (s *IncidentService) AddComment(incidentID uint, comment string, isPublic bool, userID uint) error {
	if comment == "" {
		return fmt.Errorf("comment cannot be empty")
	}
	
	incidentComment := &models.IncidentComment{
		IncidentID: incidentID,
		AuthorID:   userID,
		Comment:    comment,
		IsPublic:   isPublic,
		IsWorkNote: false,
	}
	
	if err := s.incidentRepo.AddComment(incidentComment); err != nil {
		return fmt.Errorf("failed to add comment: %w", err)
	}
	
	// Send notification if public comment
	if isPublic {
		go s.sendCommentNotification(incidentID, comment, userID)
	}
	
	return nil
}

// AddWorkNote adds a work note to an incident
func (s *IncidentService) AddWorkNote(incidentID uint, note string, userID uint) error {
	if note == "" {
		return fmt.Errorf("work note cannot be empty")
	}
	
	workNote := &models.IncidentComment{
		IncidentID: incidentID,
		AuthorID:   userID,
		Comment:    note,
		IsPublic:   false,
		IsWorkNote: true,
	}
	
	return s.incidentRepo.AddComment(workNote)
}

// GetComments retrieves all comments for an incident
func (s *IncidentService) GetComments(incidentID uint) ([]*models.IncidentComment, error) {
	return s.incidentRepo.GetComments(incidentID)
}

// NotifyStakeholders sends notifications to all stakeholders
func (s *IncidentService) NotifyStakeholders(incidentID uint, message string) error {
	incident, err := s.incidentRepo.GetByID(incidentID)
	if err != nil {
		return err
	}
	
	// Get stakeholder list
	stakeholders := s.getStakeholders(incident)
	
	// Send notifications
	for _, stakeholder := range stakeholders {
		go s.sendStakeholderNotification(stakeholder, incident, message)
	}
	
	return nil
}

// AddAttachment adds an attachment to an incident
func (s *IncidentService) AddAttachment(incidentID uint, fileName, filePath string, fileSize int64, contentType string, userID uint) error {
	attachment := &models.IncidentAttachment{
		IncidentID:   incidentID,
		FileName:     fileName,
		FilePath:     filePath,
		FileSize:     fileSize,
		ContentType:  contentType,
		UploadedByID: userID,
	}
	
	return s.incidentRepo.AddAttachment(attachment)
}

// GetAttachments retrieves all attachments for an incident
func (s *IncidentService) GetAttachments(incidentID uint) ([]*models.IncidentAttachment, error) {
	return s.incidentRepo.GetAttachments(incidentID)
}

// DeleteAttachment deletes an attachment
func (s *IncidentService) DeleteAttachment(attachmentID uint) error {
	return s.incidentRepo.DeleteAttachment(attachmentID)
}

// GetHistory retrieves the history for an incident
func (s *IncidentService) GetHistory(incidentID uint) ([]*models.IncidentHistory, error) {
	return s.incidentRepo.GetHistory(incidentID)
}

// AuditEntry represents an audit trail entry
type AuditEntry struct {
	Timestamp   time.Time
	User        string
	Action      string
	Details     string
	OldValue    string
	NewValue    string
}

// GetAuditTrail retrieves the complete audit trail for an incident
func (s *IncidentService) GetAuditTrail(incidentID uint) ([]AuditEntry, error) {
	history, err := s.incidentRepo.GetHistory(incidentID)
	if err != nil {
		return nil, err
	}
	
	var entries []AuditEntry
	for _, h := range history {
		entry := AuditEntry{
			Timestamp: h.CreatedAt,
			Action:    h.ChangeType,
			Details:   h.FieldName,
			OldValue:  h.OldValue,
			NewValue:  h.NewValue,
		}
		
		// Get user info if available
		if h.ChangedBy != nil {
			entry.User = h.ChangedBy.Name
		}
		
		entries = append(entries, entry)
	}
	
	return entries, nil
}

// SLAStatus represents the SLA status of an incident
type SLAStatus struct {
	ResponseDue      *time.Time
	ResolutionDue    *time.Time
	ResponseMet      bool
	ResolutionMet    bool
	ResponseRemaining time.Duration
	ResolutionRemaining time.Duration
	IsBreached       bool
}

// CalculateSLA calculates SLA times for an incident
func (s *IncidentService) CalculateSLA(incident *models.Incident) error {
	// This would integrate with the SLA service
	// For now, use simple calculation based on priority
	
	now := time.Now()
	
	switch incident.Priority {
	case 1: // Critical
		responseTime := now.Add(15 * time.Minute)
		resolutionTime := now.Add(2 * time.Hour)
		incident.ResponseDue = &responseTime
		incident.ResolutionDue = &resolutionTime
	case 2: // High
		responseTime := now.Add(30 * time.Minute)
		resolutionTime := now.Add(4 * time.Hour)
		incident.ResponseDue = &responseTime
		incident.ResolutionDue = &resolutionTime
	case 3: // Medium
		responseTime := now.Add(2 * time.Hour)
		resolutionTime := now.Add(8 * time.Hour)
		incident.ResponseDue = &responseTime
		incident.ResolutionDue = &resolutionTime
	case 4: // Low
		responseTime := now.Add(4 * time.Hour)
		resolutionTime := now.Add(24 * time.Hour)
		incident.ResponseDue = &responseTime
		incident.ResolutionDue = &resolutionTime
	default:
		responseTime := now.Add(8 * time.Hour)
		resolutionTime := now.Add(48 * time.Hour)
		incident.ResponseDue = &responseTime
		incident.ResolutionDue = &resolutionTime
	}
	
	return nil
}

// CheckSLACompliance checks the SLA compliance of an incident
func (s *IncidentService) CheckSLACompliance(incidentID uint) (*SLAStatus, error) {
	incident, err := s.incidentRepo.GetByID(incidentID)
	if err != nil {
		return nil, err
	}
	
	now := time.Now()
	status := &SLAStatus{
		ResponseDue:   incident.ResponseDue,
		ResolutionDue: incident.ResolutionDue,
		ResponseMet:   incident.ResponseMet,
		ResolutionMet: incident.ResolutionMet,
	}
	
	// Calculate remaining time
	if incident.ResponseDue != nil && incident.AssignedAt == nil {
		status.ResponseRemaining = incident.ResponseDue.Sub(now)
		if status.ResponseRemaining < 0 {
			status.IsBreached = true
		}
	}
	
	if incident.ResolutionDue != nil && incident.ResolvedAt == nil {
		status.ResolutionRemaining = incident.ResolutionDue.Sub(now)
		if status.ResolutionRemaining < 0 {
			status.IsBreached = true
		}
	}
	
	return status, nil
}

// UpdateSLATimes updates SLA times for an incident
func (s *IncidentService) UpdateSLATimes(incidentID uint) error {
	incident, err := s.incidentRepo.GetByID(incidentID)
	if err != nil {
		return err
	}
	
	// Recalculate SLA based on current priority
	if err := s.CalculateSLA(incident); err != nil {
		return err
	}
	
	return s.incidentRepo.Update(incident)
}

// GetIncidentMetrics retrieves incident metrics
func (s *IncidentService) GetIncidentMetrics(from, to time.Time) (*repository.IncidentMetrics, error) {
	return s.incidentRepo.GetMetrics(from, to)
}

// GetSLACompliance retrieves SLA compliance metrics
func (s *IncidentService) GetSLACompliance(from, to time.Time) (*repository.SLAMetrics, error) {
	return s.incidentRepo.GetSLACompliance(from, to)
}

// GetTrendAnalysis performs trend analysis
func (s *IncidentService) GetTrendAnalysis(period string) (*repository.TrendAnalysis, error) {
	return s.incidentRepo.GetTrendAnalysis(period)
}

// IncidentReport represents a comprehensive incident report
type IncidentReport struct {
	Incident        *models.Incident
	Timeline        []TimelineEntry
	ImpactAnalysis  string
	RootCause       string
	Resolution      string
	LessonsLearned  string
	Recommendations []string
	Metrics         map[string]interface{}
}

// TimelineEntry represents an entry in the incident timeline
type TimelineEntry struct {
	Timestamp   time.Time
	Event       string
	Description string
	User        string
}

// GenerateIncidentReport generates a comprehensive report for an incident
func (s *IncidentService) GenerateIncidentReport(incidentID uint) (*IncidentReport, error) {
	incident, err := s.incidentRepo.GetByID(incidentID)
	if err != nil {
		return nil, err
	}
	
	// Get history for timeline
	history, err := s.incidentRepo.GetHistory(incidentID)
	if err != nil {
		return nil, err
	}
	
	// Build timeline
	var timeline []TimelineEntry
	for _, h := range history {
		entry := TimelineEntry{
			Timestamp:   h.CreatedAt,
			Event:       h.ChangeType,
			Description: fmt.Sprintf("%s changed from %s to %s", h.FieldName, h.OldValue, h.NewValue),
		}
		if h.ChangedBy != nil {
			entry.User = h.ChangedBy.Name
		}
		timeline = append(timeline, entry)
	}
	
	// Calculate metrics
	metrics := make(map[string]interface{})
	if incident.TimeToRespond != nil {
		metrics["time_to_respond"] = *incident.TimeToRespond
	}
	if incident.TimeToResolve != nil {
		metrics["time_to_resolve"] = *incident.TimeToResolve
	}
	metrics["reopen_count"] = incident.ReopenCount
	metrics["escalation_level"] = incident.EscalationLevel
	
	report := &IncidentReport{
		Incident:       incident,
		Timeline:       timeline,
		ImpactAnalysis: incident.ServiceImpact,
		RootCause:      incident.RootCause,
		Resolution:     incident.ResolutionNotes,
		Metrics:        metrics,
	}
	
	// Generate recommendations based on incident data
	report.Recommendations = s.generateRecommendations(incident)
	
	return report, nil
}

// DeclareMajorIncident declares an incident as a major incident
func (s *IncidentService) DeclareMajorIncident(incidentID uint, userID uint) error {
	incident, err := s.incidentRepo.GetByID(incidentID)
	if err != nil {
		return err
	}
	
	// Update incident
	incident.IsMajorIncident = true
	incident.Severity = models.SeverityCritical
	incident.Priority = 1
	
	if err := s.incidentRepo.Update(incident); err != nil {
		return fmt.Errorf("failed to declare major incident: %w", err)
	}
	
	// Create war room
	if _, err := s.CreateWarRoom(incidentID); err != nil {
		fmt.Printf("Warning: Failed to create war room: %v\n", err)
	}
	
	// Send major incident notifications
	go s.sendMajorIncidentNotification(incidentID)
	
	// Trigger major incident workflow
	go s.TriggerWorkflow(incidentID, "major_incident")
	
	return nil
}

// WarRoom represents a major incident war room
type WarRoom struct {
	IncidentID   uint
	Name         string
	Participants []string
	Bridge       string
	ChatChannel  string
	CreatedAt    time.Time
}

// CreateWarRoom creates a war room for major incident management
func (s *IncidentService) CreateWarRoom(incidentID uint) (*WarRoom, error) {
	incident, err := s.incidentRepo.GetByID(incidentID)
	if err != nil {
		return nil, err
	}
	
	warRoom := &WarRoom{
		IncidentID:  incidentID,
		Name:        fmt.Sprintf("War Room - %s", incident.IncidentNumber),
		Bridge:      s.generateBridgeNumber(),
		ChatChannel: fmt.Sprintf("#incident-%s", strings.ToLower(incident.IncidentNumber)),
		CreatedAt:   time.Now(),
	}
	
	// Get participants
	warRoom.Participants = s.getWarRoomParticipants(incident)
	
	// Note: In a real implementation, this would integrate with 
	// communication platforms (Slack, Teams, etc.)
	
	return warRoom, nil
}

// UpdateIncidentPriority updates the priority of an incident
func (s *IncidentService) UpdateIncidentPriority(incidentID uint, impact, urgency int, userID uint) error {
	incident, err := s.incidentRepo.GetByID(incidentID)
	if err != nil {
		return err
	}
	
	oldPriority := incident.Priority
	incident.Impact = impact
	incident.Urgency = urgency
	incident.CalculatePriority()
	
	if err := s.incidentRepo.Update(incident); err != nil {
		return fmt.Errorf("failed to update priority: %w", err)
	}
	
	// Add history entry
	history := &models.IncidentHistory{
		IncidentID:  incidentID,
		FieldName:   "priority",
		OldValue:    fmt.Sprintf("%d", oldPriority),
		NewValue:    fmt.Sprintf("%d", incident.Priority),
		ChangedByID: userID,
		ChangeType:  "priority_change",
	}
	if err := s.incidentRepo.AddHistory(history); err != nil {
		fmt.Printf("Warning: Failed to add history: %v\n", err)
	}
	
	// Update SLA if priority changed
	if oldPriority != incident.Priority {
		if err := s.UpdateSLATimes(incidentID); err != nil {
			fmt.Printf("Warning: Failed to update SLA times: %v\n", err)
		}
	}
	
	return nil
}

// ApplyAutomationRules applies automation rules to an incident
func (s *IncidentService) ApplyAutomationRules(incident *models.Incident) error {
	// Auto-assignment based on category
	if incident.AssignedToID == nil {
		if err := s.autoAssign(incident); err != nil {
			fmt.Printf("Warning: Auto-assignment failed: %v\n", err)
		}
	}
	
	// Auto-escalation for critical incidents
	if incident.Severity == models.SeverityCritical && incident.EscalationLevel == 0 {
		if err := s.incidentRepo.Escalate(incident.ID, 2); err != nil {
			fmt.Printf("Warning: Auto-escalation failed: %v\n", err)
		}
	}
	
	// Auto-link to known problems
	if err := s.autoLinkToProblems(incident); err != nil {
		fmt.Printf("Warning: Auto-linking to problems failed: %v\n", err)
	}
	
	return nil
}

// TriggerWorkflow triggers a workflow for an incident
func (s *IncidentService) TriggerWorkflow(incidentID uint, workflowName string) error {
	// This would integrate with the workflow service
	// For now, just log it
	fmt.Printf("Triggering workflow '%s' for incident %d\n", workflowName, incidentID)
	return nil
}

// Helper methods

// isValidStatusTransition checks if a status transition is valid
func (s *IncidentService) isValidStatusTransition(from, to models.IncidentStatus) bool {
	validTransitions := map[models.IncidentStatus][]models.IncidentStatus{
		models.IncidentStatusNew: {
			models.IncidentStatusAssigned,
			models.IncidentStatusInProgress,
			models.IncidentStatusClosed,
		},
		models.IncidentStatusAssigned: {
			models.IncidentStatusInProgress,
			models.IncidentStatusPending,
			models.IncidentStatusResolved,
			models.IncidentStatusClosed,
		},
		models.IncidentStatusInProgress: {
			models.IncidentStatusPending,
			models.IncidentStatusResolved,
			models.IncidentStatusClosed,
		},
		models.IncidentStatusPending: {
			models.IncidentStatusInProgress,
			models.IncidentStatusResolved,
			models.IncidentStatusClosed,
		},
		models.IncidentStatusResolved: {
			models.IncidentStatusClosed,
			models.IncidentStatusInProgress,
		},
		models.IncidentStatusClosed: {
			models.IncidentStatusInProgress,
		},
	}
	
	allowed, exists := validTransitions[from]
	if !exists {
		return false
	}
	
	for _, status := range allowed {
		if status == to {
			return true
		}
	}
	
	return false
}

// autoAssign automatically assigns an incident based on rules
func (s *IncidentService) autoAssign(incident *models.Incident) error {
	// Simple auto-assignment based on category
	// In a real implementation, this would use more sophisticated rules
	
	assignmentMap := map[models.IncidentCategory]uint{
		models.CategoryHardware:    1, // Hardware team
		models.CategorySoftware:    2, // Software team
		models.CategoryNetwork:     3, // Network team
		models.CategorySecurity:    4, // Security team
		models.CategoryAccess:      5, // Access management team
		models.CategoryPerformance: 6, // Performance team
	}
	
	if groupID, exists := assignmentMap[incident.Category]; exists {
		incident.AssignmentGroupID = &groupID
	}
	
	return nil
}

// autoLinkToProblems automatically links incidents to known problems
func (s *IncidentService) autoLinkToProblems(incident *models.Incident) error {
	// This would search for known problems with similar symptoms
	// For now, just a placeholder
	return nil
}

// getStakeholders gets the list of stakeholders for an incident
func (s *IncidentService) getStakeholders(incident *models.Incident) []uint {
	var stakeholders []uint
	
	// Add reporter
	stakeholders = append(stakeholders, incident.ReportedByID)
	
	// Add assignee
	if incident.AssignedToID != nil {
		stakeholders = append(stakeholders, *incident.AssignedToID)
	}
	
	// Add affected user
	if incident.AffectedUserID != nil {
		stakeholders = append(stakeholders, *incident.AffectedUserID)
	}
	
	// Add service owner
	// This would look up the service owner from the service
	
	return stakeholders
}

// getWarRoomParticipants gets participants for a war room
func (s *IncidentService) getWarRoomParticipants(incident *models.Incident) []string {
	var participants []string
	
	// Add incident manager
	if incident.AssignedTo != nil {
		participants = append(participants, incident.AssignedTo.Email)
	}
	
	// Add service owner
	// Add technical leads
	// Add communication lead
	// etc.
	
	return participants
}

// generateBridgeNumber generates a conference bridge number
func (s *IncidentService) generateBridgeNumber() string {
	// Generate a random bridge number
	return fmt.Sprintf("1-800-555-%04d", time.Now().Unix()%10000)
}

// generateRecommendations generates recommendations based on incident
func (s *IncidentService) generateRecommendations(incident *models.Incident) []string {
	var recommendations []string
	
	// Based on resolution time
	if incident.TimeToResolve != nil && *incident.TimeToResolve > 240 {
		recommendations = append(recommendations, 
			"Consider improving documentation for this type of incident")
	}
	
	// Based on reopen count
	if incident.ReopenCount > 0 {
		recommendations = append(recommendations,
			"Implement root cause analysis to prevent recurrence")
	}
	
	// Based on escalation
	if incident.EscalationLevel > 2 {
		recommendations = append(recommendations,
			"Review escalation procedures and initial assignment rules")
	}
	
	return recommendations
}

// Notification methods (placeholders)

func (s *IncidentService) sendIncidentCreatedNotifications(incident *models.Incident) {
	// Send notifications to relevant parties
}

func (s *IncidentService) sendAssignmentNotification(incidentID uint, assigneeID uint) {
	// Send notification to assignee
}

func (s *IncidentService) sendStatusChangeNotification(incidentID uint, status models.IncidentStatus) {
	// Send status change notifications
}

func (s *IncidentService) sendEscalationNotification(incidentID uint, level int, reason string) {
	// Send escalation notifications
}

func (s *IncidentService) sendResolutionNotification(incidentID uint) {
	// Send resolution notifications
}

func (s *IncidentService) sendReopenNotification(incidentID uint, reason string) {
	// Send reopen notifications
}

func (s *IncidentService) sendCommentNotification(incidentID uint, comment string, userID uint) {
	// Send comment notifications
}

func (s *IncidentService) sendStakeholderNotification(stakeholderID uint, incident *models.Incident, message string) {
	// Send stakeholder notification
}

func (s *IncidentService) sendMajorIncidentNotification(incidentID uint) {
	// Send major incident notifications
}